# design_patternDesign Pattern (=생성, 구조, 행위)

* 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식

## 1. 생성 패턴 : 클래스나 객체의 생성과 관련된 패턴

* 추상 팩토리 : 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관하는 객체들의 그룹으로 생성하여 추상적으로 표현. 동일한 주제의 다른 팩토리 묶어줌 ex) People -> student
* 팩토리 메소드 : 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴. 생성할 객체의 클래스를 국한하지 않고 객체 생성 ex) student1, student2, student3
* 싱글톤 : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동싱에 참조할 수는 없음. 클래스 내에서 인스턴스는 하나 뿐. 한 클래스에 한 객체만 존재하도록 제한



## 2. 구조 패턴 (= 조합) : 클래스나 객체를 조합해 더 큰 구조로 만들 수 있게 해주는 패턴

* 컴포지트 : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴. 객체들을 트리 구조로 구성해 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현 가능. 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용
* 퍼싸드 : 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성. 서브 클래스들의 사이의 통합 인터페이스를 제공하는 wrapper 객체가 필요. 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스 제공
* 프록시 : 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역 제공. 네트워크 연결
* 어댑터 : 호환성이 없는 클래스의 인터페이스를 다른 클래스가 이용할 수 있도록 변환.
* 브리지 : 구현부에서 추상층을 분리해, 서로가 독립적으로 확장할 수 있도록 구성한 패턴. 기능과 구현을 두 개의 별도 클래스로 구현.
* 데코레이터 : 객체 간의 결합을 통해 능동적으로 기능 확장



## 3. 행위 패턴 (=상호작용) : 클래스나 객체가 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

* 옵서버 : 한 객체의 상태가 변화하면, 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴. 어떤 클래스에 변화가 일어났을 때, 이를 감지해 다른 클래스에 통보
* 템플릿 메소드 : 상위 클래스에서는 추상적으로 표현, 그 구체적인 내용은 하위 클래스에서 결정되는 디자인 패턴
* 책임 연쇄 : 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어감.
* 커맨드 : 요청을 객체의 형태로 캡슐화해 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남김
* 인터프리터 : 언어에 문법 표현을 정의.
* 메멘토 : 특정 시점에서 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공



---

문제 1. 디자인 패턴 중 ㅁㅁ 패턴은 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것 : 행위

문제 2. 행위 패턴 중 ㅁㅁ패턴은 어떤 클래스에 변화가 일어났을 때, 이를 감지해 다른 클래스에 통보해주는 패턴 : 옵서버

문제 3. 디자인 패턴에는 생성, 구조, ㅁㅁ가 있다. : 행위





* 실제 객체에 대한 대리 객체로, 실제 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량 아낌. 더불어 정보은닉의 역할도 수행
  * Proxy

* 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 시, 기능 처리의 연결 변경이 불가능한데 이를 동적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결한 패턴
  * chain of responsibility

* 실행될 기능을 캡슐화함으로써 주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계하는 패턴. 하나의 추상 클래스에 메서드를 만들어 각 명령이 들어오면 그에 맞는 서브클래스가 선택되어 실행되는 특징
  * command

* 상위 클래스에서 객체를 생성하는 인터페이스 정의, 하위 클래스에서 인스턴스 생성. 상위클래스에서는 인스턴스를 만드는 방법만 결정, 하위클래스에서 그 데이터의 생성 책임지고 조작하는 함수 오버로딩해 인터페이스와 실제 객체를 생성하는 클래스 분리
  * factory method
* 기능의 클래스 계층과 구현의 클래스 계층을 연결하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴
  * bridge

* 객체들의 관계를 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴으로, 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴
  * composite

* 객체 상태를 캡슐화하여 클래스화 함으로써 그것을 참조하게 하는 방식. 상태에 따라 다르게 처리할 수 있도록 행위 내용을 변경하여, 변경 시 원시 코드의 수정을 최소화 할 수 있고 유지 보수의 편의성도 갖는 패턴
  * state
* 알고리즘 군을 정의하고 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 하는 패턴. 행위를 클래스로 캡슐화해 동적으로 행위를 자유롭게 바꿀 수 있게 해주는 패턴
  * strategy
* 각 클래스 데이터 구조로부터 처리 기능을 분리해 별도의 클래스를 만들어 놓고 해당 클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행하도록 만드는 패턴. 객체의 구조는 변경하지 않고 기능만 따로 추가하거나 확장할 때 사용
  * Visitor
* 객체지향 설계에서 객체의 수가 너무 많아지면 서로 통신하느라 복잡해져 느슨한 결합의 특성을 해칠 수 있음. 따라서 중간에 이를 통제하고 지시할 수 있는 역할을 하는 중재자를 두고 요구해 통신의 빈도수를 줄여 객체지향의 목표를 달성하게 해주는 디자인 패턴
  * mediator

* 복잡한 시스템에 대하여 단순한 인터페이스를 제공함으로써 사용자와 시스템 간,  여타 시스템 간의 결합도를 낮추어 시스템 구조에 대한 파악을 쉽게 하는 패턴. 사용자 측면에서 단순한 인터페이스를 제공해 접근성을 높일 수 있음
  * facade
* 다수의 객체로 생성될 경우 모두가 갖는 본질적인 요소를 클래스화하여 공유함으로서 메모리 절약. 클래스 경량화가 목적
  * flyweight

----

* 구체적인 클래스에 의존하지 않고 서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공하는 패턴. 사용자에게 API 제공하고 구체적인 구현은 concrete product 클래스에서 이루어지는 특징을 갖는 패턴
  * 추상팩토리
* 전역변수를 사용하지 않고 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 함
  * 싱글톤
* 복잡한 인스턴스를 조립하여 만드는 구조, 복합 객체를 생성할 때 객체를 생성하는 방법과 객체를 구현하는 방법을 분리함으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있는 디자인 패턴
  * 빌더

* 기존 생성된 클래스를 재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드는 패턴. 상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태로 사용되는 디자인 패턴
  * Adapter

* 처음부터 일반적인 원형을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용하는 패턴. 
  * 프로토타입
* 기존에 구현되어 있는 클래스에 그때그때 필요한 기능을 추가해 나가는 설계 패턴
  * decorator
* 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신됨
  * observer
* 컬렉션 구현 방법을 노출시키지 않으면서도 그 집합체 안에 들어있는 모든 항목에 접근할 수 있는 방법을 제공하는 디자인 패턴
  * Iterator
* 어떤 작업을 처리하는 일부분을 서브 클래스로 캡슐화해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴. 상위 클래스에는 추상 메서드로 기능의 골격 제공하고 하위 클래스는 세부 처리를 구체화하는 방식으로 사용하여 코드 양을 줄이고 유지보수를 용이하게 만드는 특징을 갖는 패턴
  * Template Method
* 클래스 설계 관점에서 객체의 정보를 저장할 필요가 있을 때 적용하는 디자인 패턴
  * memento
* 언어의 다양한 해석, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만드는 패턴
  * interpreter











