# design_patternDesign Pattern (=생성, 구조, 행위)

* 모듈 간의 관계 및 인터페이스를 설계할 때 참조할 수 있는 전형적인 해결 방식

## 1. 생성 패턴 : 클래스나 객체의 생성과 관련된 패턴

* 추상 팩토리 : 구체적인 클래스에 의존하지 않고, 인터페이스를 통해 서로 연관하는 객체들의 그룹으로 생성하여 추상적으로 표현. 동일한 주제의 다른 팩토리 묶어줌 ex) People -> student
* 팩토리 메소드 : 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴. 생성할 객체의 클래스를 국한하지 않고 객체 생성 ex) student1, student2, student3
* 싱글톤 : 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동싱에 참조할 수는 없음. 클래스 내에서 인스턴스는 하나 뿐. 한 클래스에 한 객체만 존재하도록 제한



## 2. 구조 패턴 (= 조합) : 클래스나 객체를 조합해 더 큰 구조로 만들 수 있게 해주는 패턴

* 컴포지트 : 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴. 객체들을 트리 구조로 구성해 디렉터리 안에 디렉터리가 있듯이 복합 객체 안에 복합 객체가 포함되는 구조를 구현 가능. 0개, 1개 혹은 그 이상의 객체를 묶어 하나의 객체로 이용
* 퍼싸드 : 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성. 서브 클래스들의 사이의 통합 인터페이스를 제공하는 wrapper 객체가 필요. 많은 분량의 코드에 접근할 수 있는 단순한 인터페이스 제공
* 프록시 : 접근 조절, 비용 절감, 복잡도 감소를 위해 접근이 힘든 객체에 대한 대역 제공. 네트워크 연결
* 어댑터 : 호환서잉 없는 클래스의 인터페이스를 다른 클래스가 이용할 수 있도록 변환.
* 브리지 : 구현부에서 추상층을 분리해, 서로가 독립적으로 확장할 수 있도록 구성한 패턴. 기능과 구현을 두 개의 별도 클래스로 구현.
* 데코레이터 : 객체 간의 결합을 통해 능동적으로 기능 확장



## 3. 행위 패턴 (=상호작용) : 클래스나 객체가 서로 상호작용하는 방법이나 책임 분배 방법을 정의하는 패턴

* 커맨드 : 재사용성이 높은 클래스를 설계
* 옵서버 : 한 객체의 상태가 변화하면, 객체에 상속되어 있는 다른 객체들에게 변화된 상태를 전달하는 패턴. 어떤 클래스에 변화가 일어났을 때, 이를 감지해 다른 클래스에 통보
* 템플릿 메소드 : 상위 클래스에서는 추상적으로 표현, 그 구체적인 내용은 하위 클래스에서 결정되는 디자인 패턴
* 책임 연쇄 : 요청을 처리할 수 있는 객체가 둘 이상 존재하여 한 객체가 처리하지 못하면 다음 객체로 넘어감.
* 커맨드 : 요청을 객체의 형태로 캡슐화해 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장하거나 로그에 남김
* 인터프리터 : 언어에 문법 표현을 정의.
* 메멘토 : 특정 시점에서 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 수 있는 기능 제공





문제 1. 디자인 패턴 중 ㅁㅁ 패턴은 반복적으로 사용되는 객체들의 상호작용을 패턴화한 것

문제 2. 행위 패턴 중 ㅁㅁ패턴은 어떤 클래스에 변화가 일어났을 때, 이를 감지해 다른 클래스에 통보해주는 패턴

문제 3. 디자인 패턴에는 생성, 구조, ㅁㅁ가 있다.